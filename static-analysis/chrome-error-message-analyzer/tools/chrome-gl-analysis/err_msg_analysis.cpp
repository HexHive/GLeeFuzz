#include <iostream>
#include <fstream>
#include <string>
#include <tuple>

#include <nlohmann/json.hpp>

#include "SVF-FE/LLVMUtil.h"
#include "SVF-FE/CPPUtil.h"

#include "Util/SVFUtil.h"

#include "Graphs/SVFG.h"
#include "WPA/Andersen.h"
#include "SVF-FE/SVFIRBuilder.h"
#include "Util/BasicTypes.h"
#include "Util/SVFUtil.h"
#include "Util/Options.h"


#include "svf_utils.hpp"
#include "llvm_utils.hpp"

using namespace llvm;
using namespace std;
using namespace SVF;

using json = nlohmann::json;

// https://source.chromium.org/chromium/chromium/src/+/main:third_party/khronos/GLES3/gl3.h;l=146?q=%20GL_INVALID_OPERATION%20&ss=chromium
// #define GL_INVALID_OPERATION 0x0502
const int TYPE2_EC=0x0502;

cl::OptionCategory
cat("err_msg_analysis Options",
    "These control the inputs to err_msg_analysis tool.");

static cl::opt<string>
ir("ir", cl::desc("Specify WebGL API IR file"),
   cl::value_desc("IR file"), cl::Required,
   cl::cat(cat));

static cl::opt<string>
am_file("am",
        cl::desc("Specify the json file containing api func "
                 "mapping result (generated by api_func_parse)"),
        cl::value_desc("api_func_map"),
        cl::Required,
        cl::cat(cat));

static cl::opt<int>
api_id("api_id", cl::desc("the api to analysis (with id)"),
       cl::value_desc("the id of the api"),
       cl::init(-1),
       cl::cat(cat));

static cl::opt<string> eef("eef", cl::desc("the name of error message emitting function"),
                        cl::value_desc("the manged function name"),
                        cl::init("_ZN5blink25WebGLRenderingContextBase17"
                                 "SynthesizeGLErrorEjPKcS2_NS0_24ConsoleDisplayPreferenceE"),
                        cl::cat(cat));

void dumpInternalSummary(map<string, set<int>> &summary) {
    for (auto it = summary.begin(); it != summary.end(); it ++) {
        const string &sname = it->first;
        const set<int> &offsets = it->second;

        llvm::outs()  << sname << ":";
        for (auto offset: offsets) {
            llvm::outs() << offset << ",";
        }
        llvm::outs() << "\n";
    }
}


static const Value *
computeConditionVal(const Instruction *i) {
    if (auto *bi = dyn_cast<BranchInst>(i)) {
        if (bi->isConditional()) {
            return bi->getCondition();
        }
    } else if (auto *si = dyn_cast<SwitchInst>(i)) {
        return  si->getCondition();
    } else {
        assert(false && "unexpected type of condition instruction");
    }

    return nullptr;
}

static void
analyzeOneErrInst(ICFG *icfg,
                  VFG *vfg,
                  const SVFFunction *svfFun,
                  const CallInst *ci) {

    tuple<string, int> einfo = extract_log_message_from_callinst(ci);
    string &errMsg = get<0>(einfo);
    int errCode = get<1>(einfo);

    auto conditions = computeConditions(icfg, ci);
    assert(conditions.size() > 0 && "No condition found");

    const Value *c = nullptr;
    const Instruction *inst = nullptr;
    int i = 0;
    do {
        inst = conditions[i];
        c = computeConditionVal(inst);
    } while (c == nullptr && ++i < conditions.size());

    assert(c  != nullptr && "No non-null condition found");

    if (errCode == TYPE2_EC) {
        llvm::outs() << "type 2: " << errMsg<< " {\n";

        llvm::outs() << "}\n";
    } else {
        llvm::outs() << "type 1: " << errMsg << " {\n";
        llvm::outs() << "}\n";
    }
}

static void
analyzeOneAPI(SVFModule *svfModule,
              ICFG *icfg,
              VFG *vfg,
              json &api_mapping) {

    int api_id = api_mapping["id"].get<int>();
    string api_name = api_mapping["name"].get<string>();
    string llvm_fname = api_mapping["llvm_fname"].get<string>();

    const SVFFunction *svfFun = getFunctionByName(svfModule, llvm_fname);

    if (svfFun == nullptr) {
        llvm::outs() << "Could not find the LLVM function for API: " << api_name << "\n";
        return;
    }

    llvm::outs() << "id: " << api_id << ", name: " << api_name << " {\n";

    set<const Instruction *> errorEmittingInsts = collectErrEmittingInsts(icfg, eef.getValue(), svfFun);

    for (auto v : errorEmittingInsts) {
        llvm::outs() << *v << "\n";
        llvm::outs() << SVFUtil::getSourceLoc(v) << "\n";
        if (auto *ci = llvm::dyn_cast<CallInst>(v)) {
            analyzeOneErrInst(icfg, vfg, svfFun, ci);
        } else {
            llvm::outs() << "XXXXX Not a CallInst\n";
        }
    }

    llvm::outs() << "}\n";
}

int main(int argc, char **argv) {
    cl::ParseCommandLineOptions(argc, argv, "Analyzing error messages of APIs\n");

    SVFModule* svfModule = LLVMModuleSet::getLLVMModuleSet()->buildSVFModule({ir});
    svfModule->buildSymbolTableInfo();

    SVFIRBuilder builder;
    SVFIR* pag = builder.build(svfModule);
    ICFG* icfg = pag->getICFG();

    Andersen* ander = AndersenWaveDiff::createAndersenWaveDiff(pag);
    SVFGBuilder svfBuilder(true);
    SVFG* svfg = svfBuilder.buildFullSVFG(ander);

    ifstream ifs(am_file.getValue());
    json am;
    ifs >> am;
    json &mapping = am["mappings"];
    int sid = api_id.getValue();
    if (sid >= 0 && sid < mapping.size()) {
        json &api_mapping = mapping[api_id.getValue()];
        analyzeOneAPI(svfModule, icfg, svfg, api_mapping);
    } else {
        for (int i = 0; i < mapping.size(); i ++) {
            analyzeOneAPI(svfModule, icfg, svfg, mapping[i]);
        }
    }

    delete svfg;

    // delete vfg;
    AndersenWaveDiff::releaseAndersenWaveDiff();
    SVFIR::releaseSVFIR();
    SVF::LLVMModuleSet::releaseLLVMModuleSet();
    llvm::llvm_shutdown();

    return 0;
}
